<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>DNS</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>dns.lua</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>dns.client</strong></li>
  <li><a href="../modules/dns.utils.html">dns.utils</a></li>
</ul>
<h2>Topics</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>dns.client</code></h1>
<p>DNS client.</p>
<p> The DNS client will cache entries and DNS resolver objects.</p>

<p> Requires the <code>resolver</code> module. Either <code>resty.dns.resolver</code> when used with OpenResty
 or the extracted version of that module for regular Lua.</p>

<p> <em>NOTES</em>: </p>

<ol>
    <li>parsing the config files upon initialization uses blocking i/o, so use with
    care. See <code>init()</code> for details.</li>
    <li>All returned records are directly from the cache. So do not modify them! If you
    need to, copy them first.</li>
    <li>TTL for records is the TTL returned by the server at the time of fetching
    and won't be updated while the client serves the records from its cache.</li>
    <li>records with a PRIORITY field (SRV or MX records for example) will be sorted
    by priority</li>
    <li>resolving IPv4 (A-type) and IPv6 (AAAA-type) addresses is explicitly supported.
    Their records will be cached with a ttl of 10 years.</li>
</ol>

<p> See <code>./examples/</code> for examples and output returned.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: Thijs Schreijer, Mashape Inc.</li>
        <li><strong>License</strong>: Apache 2.0</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#init">init (options)</a></td>
	<td class="summary">initialize resolver.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#purge_cache">purge_cache (touched)</a></td>
	<td class="summary">Cleanup the DNS client cache.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#resolve">resolve (qname)</a></td>
	<td class="summary">Resolve a name using a generic type-order.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#resolve_type">resolve_type (qname, r_opts)</a></td>
	<td class="summary">Resolves a name following CNAME redirects.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "init"></a>
    <strong>init (options)</strong>
    </dt>
    <dd>
    initialize resolver.  Will parse hosts and resolv.conf files/tables.
 If the <code>hosts</code> and <code>resolv_conf</code> fields are not provided, it will fall back on default
 filenames (see the <a href="../modules/dns.utils.html#">dns.utils</a> module for details). To prevent any potential
 blocking i/o all together, manually fetch the contents of those files and
 provide them as tables. Or provide both fields as empty tables.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">options</span>
         Same table as the openresty dns resolver, with extra fields <code>hosts</code>, <code>resolv_conf</code> containing the filenames to parse, and <code>max_resolvers</code> indicating the maximum number of resolver objects to cache.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil+error otherwise
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="comment">-- initialize without any blocking i/o
</span> <span class="keyword">local</span> client = <span class="global">require</span>(<span class="string">"dns.client"</span>)
 <span class="global">assert</span>(client.init({
          hosts = {},
          resolv_conf = {},
        })
 )</pre>
    </ul>

</dd>
    <dt>
    <a name = "purge_cache"></a>
    <strong>purge_cache (touched)</strong>
    </dt>
    <dd>
    Cleanup the DNS client cache.  Items will be checked on TTL only upon
 retrieval from the cache. So items inserted, but never used again will
 never be removed from the cache automatically. So unless you have a very
 restricted fixed set of hostnames you're resolving, you should occasionally
 purge the cache.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">touched</span>
         in seconds. Cleanup everything (also non-expired items) not touched in <code>touched</code> seconds. If omitted, only expired items (based on ttl) will be removed.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        number of entries deleted
    </ol>




</dd>
    <dt>
    <a name = "resolve"></a>
    <strong>resolve (qname)</strong>
    </dt>
    <dd>
    Resolve a name using a generic type-order.  It will try to resolve the given
 name using the following record types, in the order listed;</p>

<ol>
    <li>last succesful lookup type (if any), </li>
    <li>A-record, </li>
    <li>AAAA-record, </li>
    <li>SRV-record.</li>
</ol>

<p> So requesting <code>mysrv.domain.com</code> (assuming to be an SRV record) will try to resolve
 it (the first time) as A, then AAAA, then SRV. If succesful, a second lookup
 will now try SRV, A, AAAA.
 This function will dereference CNAME records, but will not resolv any SRV content.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">qname</span>
         Name to resolve
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        A list of records. The list can be empty if the name is present on the server, but as a different record type. Any dns server errors are returned in a hashtable (see openresty docs).
    </ol>




</dd>
    <dt>
    <a name = "resolve_type"></a>
    <strong>resolve_type (qname, r_opts)</strong>
    </dt>
    <dd>
    Resolves a name following CNAME redirects.  CNAME will not be followed when
 the requested type is CNAME.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">qname</span>
         Same as the openresty <code>query</code> method
        </li>
        <li><span class="parameter">r_opts</span>
         Same as the openresty <code>query</code> method (defaults to A type query)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        A list of records. The list can be empty if the name is present on the server, but as a different record type. Any dns server errors are returned in a hashtable (see openresty docs).
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2016-06-13 19:06:20 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
